#pragma once

#include "/Libraries/Graphics/RayMarching.ush"

class USphereShape : IBaseShape
{
    static const float4 TransparentBackground = float4(0, 0, 0, 0);
        
    float Radius;
    float4 Color;
    
    FTransform Transform;
    FDrawParams DrawParams;
    
    FPBRParams SpherePBR;
    
    float CalcDistance(float3 RayOrigin)
    {
        float3 LocalPosition = RayOrigin - Transform.Location;
        LocalPosition = URayMarcher::RotateByEulerFast(LocalPosition, Transform.Rotation, true);

        float3 ScaledPosition = LocalPosition / (Transform.Scale * Radius);

        float LengthPrimary = length(ScaledPosition);
        float LengthSecondary = length(ScaledPosition / (Transform.Scale * Radius));
        float Distance = LengthPrimary * (LengthPrimary - 1.0f) / LengthSecondary;

        return Distance * min(Transform.Scale.x, min(Transform.Scale.y, Transform.Scale.z)) * Radius;
    }
    
    float GetDistance()
    {
        return CalcDistance(DrawParams.ViewRayOrigin);
    }
    
    void UpdateViewRayOrigin()
    {
        DrawParams.ViewRayOrigin += DrawParams.RayStep * max(DrawParams.StepSize, 0);
    }
    
    float3 GetSurfaceNormal()
    {
        const float Epsilon = KINDA_SMALL_NUMBER;

        float3 OffsetX = float3(Epsilon, 0, 0);
        float3 OffsetY = float3(0, Epsilon, 0);
        float3 OffsetZ = float3(0, 0, Epsilon);

        float DistanceCenter = CalcDistance(DrawParams.ViewRayOrigin);
        float3 Gradient = float3(
        CalcDistance(DrawParams.ViewRayOrigin + OffsetX) - DistanceCenter,
        CalcDistance(DrawParams.ViewRayOrigin + OffsetY) - DistanceCenter,
        CalcDistance(DrawParams.ViewRayOrigin + OffsetZ) - DistanceCenter
        );

        return normalize(Gradient);
    }

    
    float3 GetSurfaceReflection()
    {
        return reflect(SpherePBR.LightDirection, GetSurfaceNormal());
    }

    float3 GetRimLight()
    {
        float RimFactor = dot(GetSurfaceNormal(), SpherePBR.ViewDirection);
        RimFactor = float(1) - saturate(RimFactor);
        RimFactor = pow(RimFactor, SpherePBR.RimContrast);
        
        return SpherePBR.RimColor * RimFactor * SpherePBR.RimStrength;
    }
    
    float3 GetSpecular()
    {
        float3 Specular = dot(GetSurfaceReflection(), -SpherePBR.ViewDirection);
        Specular = pow(max(Specular, 0), SpherePBR.SpecularSoftness);
        
        return Specular * SpherePBR.SpecularColor;
    }
    
    float3 GetForwardPass()
    {
        float3 Diffuse = dot(GetSurfaceNormal(), SpherePBR.LightDirection);

        float3 ShadowContrast = max(SpherePBR.ShadowContrast, 1);
        
        float3 Base = max(Diffuse * ShadowContrast, SpherePBR.AmbientLight);
        
        return Base + GetRimLight() + GetSpecular();
    }
        
    float4 Draw()
    {
        bool HasHit = URayMarcher::DrawShape3D(
            this,
            DrawParams.NumSteps,
            DrawParams.OverlapDetectionThreshold
        );
        
        if (HasHit)
        {
            float3 FowrardPass = GetForwardPass();
            float4 ReturnColor = float4(
                Color.x * FowrardPass.x,
                Color.y * FowrardPass.y,
                Color.z * FowrardPass.z,
                Color.w
            );
            
            return ReturnColor;
        }
        
        return TransparentBackground;
    }
};