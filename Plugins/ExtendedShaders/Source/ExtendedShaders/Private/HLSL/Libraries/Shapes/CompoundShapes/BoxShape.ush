#pragma once

#include "/Libraries/Graphics/RayMarching.ush"

class UCompoundBoolean : IBaseShape
{
    static const float4 TransparentBackground = float4(0, 0, 0, 0);

    float FirstShapeDist;
    float SecondShapeDist;
    
    float BevelRadius;
    float4 Color;
    
    FPBRParams PBRParams;
    FTransform Transform;
    FDrawParams DrawParams;
        
    float CalcDistance(float3 RayOrigin)
    {
        float3 LocalPosition = RayOrigin - Transform.Location;
        LocalPosition = URayMarcher::RotateByEulerFast(LocalPosition, Transform.Rotation, true);
        LocalPosition = abs(LocalPosition) - Transform.Scale;

        return length(max(LocalPosition, 0)) + min(max(LocalPosition.x, max(LocalPosition.y, LocalPosition.z)), 0) - BevelRadius;
    }
    
    float GetDistance()
    {
        return CalcDistance(DrawParams.ViewRayOrigin);
    }
    
    void UpdateViewRayOrigin()
    {
        DrawParams.ViewRayOrigin += DrawParams.RayStep * max(DrawParams.StepSize, 0);
    }
    
    float3 GetSurfaceNormal()
    {
        float3 LocalNormal = DrawParams.ViewRayOrigin - Transform.Location;

        float Epsilon = KINDA_SMALL_NUMBER;
        
        float DirectionX = CalcDistance(LocalNormal + float3(Epsilon, 0, 0))
             - CalcDistance(LocalNormal - float3(Epsilon, 0, 0));
        float DirectionY = CalcDistance(LocalNormal + float3(0, Epsilon, 0))
             - CalcDistance(LocalNormal - float3(0, Epsilon, 0));
        float DirectionZ = CalcDistance(LocalNormal + float3(0, 0, Epsilon))
             - CalcDistance(LocalNormal - float3(0, 0, Epsilon));
        
        return normalize(float3(DirectionX, DirectionY, DirectionZ));
    }
    
    float3 GetSurfaceReflection()
    {
        return reflect(BoxPBR.LightDirection, GetSurfaceNormal());
    }

    float3 GetRimLight()
    {
        float RimFactor = dot(GetSurfaceNormal(), BoxPBR.ViewDirection);
        RimFactor = float(1) - saturate(RimFactor);
        RimFactor = pow(RimFactor, BoxPBR.RimContrast);
        
        return BoxPBR.RimColor * RimFactor * BoxPBR.RimStrength;
    }
    
    float3 GetSpecular()
    {
        float3 Specular = dot(GetSurfaceReflection(), -BoxPBR.ViewDirection);
        Specular = pow(max(Specular, 0), BoxPBR.SpecularSoftness);
        
        return Specular * BoxPBR.SpecularColor;
    }
        
    float3 GetForwardPass()
    {
        float3 Diffuse = dot(GetSurfaceNormal(), BoxPBR.LightDirection);

        float3 ShadowContrast = max(BoxPBR.ShadowContrast, 1);
        
        float3 Base = max(Diffuse * ShadowContrast, BoxPBR.AmbientLight);
        
        return Base + GetRimLight() + GetSpecular();
    }
        
    float4 Draw()
    {
        bool HasHit = URayMarcher::DrawShape3D(
            this,
            DrawParams.NumSteps,
            DrawParams.OverlapDetectionThreshold
        );
        
        if (HasHit)
        {
            float3 FowrardPass = GetForwardPass();
            float4 ReturnColor = float4(
                Color.x * FowrardPass.x,
                Color.y * FowrardPass.y,
                Color.z * FowrardPass.z,
                Color.w
            );
            
            return ReturnColor;
        }
        
        return TransparentBackground;
    }
};