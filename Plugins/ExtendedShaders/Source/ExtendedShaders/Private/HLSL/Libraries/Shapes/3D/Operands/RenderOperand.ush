// You can use this project non-commercially for educational purposes, any
// commercial use, derivative commercial use is strictly prohibited

#pragma once

#include "/Libraries/Graphics/RayMarchingRender.ush"

#include "/Libraries/Shapes/3D/TransformManager.ush"

#include "/Libraries/Shapes/3D/Estimators/SphereEstimator.ush"
//#include "/Libraries/Shapes/3D/Estimators/BoxEstimator.ush"
//#include "/Libraries/Shapes/3D/Estimators/CyllinderEstimator.ush"

#include "/Libraries/Shapes/3D/Operands/SubtractOperand.ush"

#include "/Libraries/Shapes/3D/BaseShape.ush"

class URenderOperand : IBaseShape
{
    float4 Color;
    
    FPBRParams PBRParams;
    FDrawParams DrawParams;
        
    float InPart;
    
    FTransform Transform;
    
    float Radius;
<<<<<<< Updated upstream
    
    float GetDistance()
    {
        if (InPart == SphereType)
        {
            return USphereEstimator::CalcDistance(DrawParams.ViewRayOrigin, Transform, Radius);
        }
        //else if (InPart == BoxType)
        //{
        //    return UBoxEstimator::GetDistance(DrawParams.ViewRayOrigin);
        //}
        //else if (InPart == CyllinderType)
        //{
        //    return UCyllinderEstimator::GetDistance(DrawParams.ViewRayOrigin);
        //}
        
=======
    float BevelRadius;
    float HalfHeight;
    
    float GetDistance()
    {
        switch (InPart)
        {
            case SPHERE_TYPE:
            {
                    return USphereEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius);
                }
            
            case BOX_TYPE:
            {
                    return UBoxEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    BevelRadius);
                }
            
            case CYLLINDER_TYPE:
            {
                    return UCyllinderEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius,
                    HalfHeight,
                    BevelRadius);
                }
            
            case SUBTRACT_TYPE:
            {
                USubtractOperand SubtractOP;
                SubtractOP.SubtractTransform = Transform;
                SubtractOP.DrawParams = DrawParams;
                return 
            }
        }
>>>>>>> Stashed changes
        return 0;
    }
    
    void UpdateViewRayOrigin()
    {
        DrawParams.ViewRayOrigin += DrawParams.RayStep * max(DrawParams.StepSize, 0);
    }
    
    float GetDistanceAtOffset(float3 Offset)
    {
        // Purely additive perturbation for numerical gradient
        return InPart + dot(Offset, 1.0);
    }
    
    float3 GetSurfaceNormal()
    {
        float NormalEpsilon = KINDA_SMALL_NUMBER;
        
        // Central difference approximation of gradient
        float DistanceX = GetDistanceAtOffset(float3(NormalEpsilon, 0.0, 0.0)) -
                            GetDistanceAtOffset(float3(-NormalEpsilon, 0.0, 0.0));
        float DistanceY = GetDistanceAtOffset(float3(0.0, NormalEpsilon, 0.0)) -
                            GetDistanceAtOffset(float3(0.0, -NormalEpsilon, 0.0));
        float DistanceZ = GetDistanceAtOffset(float3(0.0, 0.0, NormalEpsilon)) -
                            GetDistanceAtOffset(float3(0.0, 0.0, -NormalEpsilon));

        float3 Gradient = float3(DistanceX, DistanceY, DistanceZ);
        return normalize(Gradient);
    }
<<<<<<< Updated upstream
=======
        
    float3 GetSurfaceNormal()
    {
        switch (InPart)
        {
            case SPHERE_TYPE:
            {
                    return USphereEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius);
                }
            
            case BOX_TYPE:
            {
                    return UBoxEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    BevelRadius);
                }
            
            case CYLLINDER_TYPE:
            {
                    return UCyllinderEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius,
                    HalfHeight,
                    BevelRadius);
                }
        }
        
        return GetCommonSurfaceNormal();
    }
>>>>>>> Stashed changes
    
    float3 GetSurfaceReflection()
    {
        return reflect(PBRParams.LightDirection, GetSurfaceNormal());
    }

    float3 GetRimLight()
    {
        float RimFactor = dot(GetSurfaceNormal(), PBRParams.ViewDirection);
        RimFactor = float(1) - saturate(RimFactor);
        RimFactor = pow(RimFactor, PBRParams.RimContrast);
        
        return PBRParams.RimColor * RimFactor * PBRParams.RimStrength;
    }
    
    float3 GetSpecular()
    {
        float3 Specular = dot(GetSurfaceReflection(), -PBRParams.ViewDirection);
        Specular = pow(max(Specular, 0), PBRParams.SpecularSoftness);
        
        return Specular * PBRParams.SpecularColor;
    }
        
    float3 GetForwardPass()
    {
        float3 Diffuse = dot(GetSurfaceNormal(), PBRParams.LightDirection);

        float3 ShadowContrast = max(PBRParams.ShadowContrast, 1);
        
        float3 Base = max(Diffuse * ShadowContrast, PBRParams.AmbientLight);
        
        return Base + GetRimLight() + GetSpecular();
    }
        
    float4 Draw()
    {
        bool HasHit = URayMarcher::DrawShape3D(
            this,
            DrawParams.NumSteps,
            DrawParams.OverlapDetectionThreshold
        );
        
        if (HasHit)
        {
            float3 FowrardPass = GetForwardPass();
            float4 ReturnColor = float4(
                Color.x * FowrardPass.x,
                Color.y * FowrardPass.y,
                Color.z * FowrardPass.z,
                Color.w
            );
            
            return ReturnColor;
        }
        
        return TRANSPARENT_BG;
    }
};