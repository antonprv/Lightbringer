// You can use this project non-commercially for educational purposes, any
// commercial use, derivative commercial use is strictly prohibited

#pragma once

#include "/Libraries/Graphics/RayMarchingRender.ush"

#include "/Libraries/Shapes/3D/TransformManager.ush"

#include "/Libraries/Shapes/3D/Estimators/SphereEstimator.ush"
#include "/Libraries/Shapes/3D/Estimators/BoxEstimator.ush"
#include "/Libraries/Shapes/3D/Estimators/CyllinderEstimator.ush"

#include "/Libraries/Shapes/3D/BaseShape.ush"

class URenderOperand // : IBaseShape
{
    float4 Color;
    
    FPBRParams PBRParams;
    FDrawParams DrawParams;
        
    float InPart;
    
    FTransform Transform;
        
    // Common shape parameters
    float Radius;
    float BevelRadius;
    float HalfHeight;
    
    float GetDistance()
    {
        switch (TO_INT(InPart))
        {
            case SPHERE_TYPE_INT:
            {
                    return USphereEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius);
                }
            
            case BOX_TYPE_INT:
            {
                    return UBoxEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    BevelRadius);
                }
            
            case CYLLINDER_TYPE_INT:
            {
                    return UCyllinderEstimator::CalcDistance(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius,
                    HalfHeight,
                    BevelRadius);
                }
        }
        return 0.;
    }
    
    void UpdateViewRayOrigin()
    {
        DrawParams.ViewRayOrigin += DrawParams.RayStep * max(DrawParams.StepSize, 0);
    }
    
    float GetDistanceAtOffset(float3 Offset)
    {
        // Purely additive perturbation for numerical gradient
        return InPart + dot(Offset, 1.0);
    }
    
    float3 GetCommonSurfaceNormal()
    {
        float NormalEpsilon = KINDA_SMALL_NUMBER;
                
        // Central difference approximation of gradient
        float DistanceX = GetDistanceAtOffset(float3(NormalEpsilon, 0.0, 0.0)) -
                            GetDistanceAtOffset(float3(-NormalEpsilon, 0.0, 0.0));
        float DistanceY = GetDistanceAtOffset(float3(0.0, NormalEpsilon, 0.0)) -
                            GetDistanceAtOffset(float3(0.0, -NormalEpsilon, 0.0));
        float DistanceZ = GetDistanceAtOffset(float3(0.0, 0.0, NormalEpsilon)) -
                            GetDistanceAtOffset(float3(0.0, 0.0, -NormalEpsilon));

        float3 Gradient = float3(DistanceX, DistanceY, DistanceZ);
        return normalize(Gradient);
    }
        
    float3 GetSurfaceNormal()
    {
        switch (TO_INT(InPart))
        {
            case SPHERE_TYPE_INT:
            {
                    return USphereEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius);
                }
            
            case BOX_TYPE_INT:
            {
                    return UBoxEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    BevelRadius);
                }
            
            case CYLLINDER_TYPE_INT:
            {
                    return UCyllinderEstimator::GetSurfaceNormal(
                    DrawParams.ViewRayOrigin,
                    Transform,
                    Radius,
                    HalfHeight,
                    BevelRadius);
                }
        }
        
        return GetCommonSurfaceNormal();
    }
    
    float3 GetSurfaceReflection()
    {
        return reflect(PBRParams.LightDirection, GetSurfaceNormal());
    }

    float3 GetRimLight()
    {
        float RimFactor = dot(GetSurfaceNormal(), PBRParams.ViewDirection);
        RimFactor = float(1) - saturate(RimFactor);
        RimFactor = pow(RimFactor, PBRParams.RimContrast);
        
        return PBRParams.RimColor * RimFactor * PBRParams.RimStrength;
    }
    
    float3 GetSpecular()
    {
        float3 Specular = dot(GetSurfaceReflection(), -PBRParams.ViewDirection);
        Specular = pow(max(Specular, 0), PBRParams.SpecularSoftness);
        
        return Specular * PBRParams.SpecularColor;
    }
        
    float3 GetForwardPass()
    {
        float3 Diffuse = dot(GetSurfaceNormal(), PBRParams.LightDirection);

        float3 ShadowContrast = max(PBRParams.ShadowContrast, 1);
        
        float3 Base = max(Diffuse * ShadowContrast, PBRParams.AmbientLight);
        
        return Base + GetRimLight() + GetSpecular();
    }
        
    float4 Draw()
    {
        bool HasHit = false;

        //HasHit = URayMarcher::DrawShape3D(
        //    this,
        //    DrawParams.NumSteps,
        //    DrawParams.OverlapDetectionThreshold
        //);
        
        for (int i = 0; i < DrawParams.NumSteps; ++i)
        {
            float Distance = GetDistance();
        
            if (Distance < DrawParams.OverlapDetectionThreshold)
            {
                HasHit = true;
                break;
            }
        
            UpdateViewRayOrigin();
        }
        
        if (HasHit)
        {
            float3 FowrardPass = GetForwardPass();
            float4 ReturnColor = float4(
                Color.x * FowrardPass.x,
                Color.y * FowrardPass.y,
                Color.z * FowrardPass.z,
                Color.w
            );
            
            return ReturnColor;
        }
        
        return TRANSPARENT_BG;
    }
};