#pragma once

#include "/Libraries/Shapes/3D/BaseShape.ush"

#define KINDA_SMALL_NUMBER 0.001

struct FPBRParams
{
    float3 LightDirection;
    float3 AmbientLight;
    float ShadowContrast;
    
    float3 ViewDirection;
    float RimStrength;
    float RimContrast;
    float3 RimColor;
    
    float3 WorldPosition;
    float SpecularSoftness;
    float3 SpecularColor;
};

class URayMarcher
{
    // Just decides whether to draw or not to draw pixel
    static bool DrawShape3D(
        IBaseShape Shape,
        int NumSteps,
        float OverlapDetectionThreshold
    )
    {
        for (int i = 0; i < NumSteps; ++i)
        {
            float Distance = Shape.GetDistance();
            
            if (Distance < OverlapDetectionThreshold)
            {
                return true;
            }

            Shape.UpdateViewRayOrigin();
        }
        
        return false;
    }

    // Rotate vector by Euler angles (Pitch=X, Yaw=Y, Roll=Z) in degrees.
    // bInverse: apply inverse rotation (approximate) using small number compensation.
    static float3 RotateByEulerFast(float3 Vector, float3 RotationDegrees, bool bInverse)
    {
        // Convert degrees to radians
        float3 RotRad = radians(RotationDegrees);

        float SinPitch = sin(RotRad.x) + KINDA_SMALL_NUMBER;
        float CosPitch = cos(RotRad.x) + KINDA_SMALL_NUMBER;
        float SinYaw = sin(RotRad.y) + KINDA_SMALL_NUMBER;
        float CosYaw = cos(RotRad.y) + KINDA_SMALL_NUMBER;
        float SinRoll = sin(RotRad.z) + KINDA_SMALL_NUMBER;
        float CosRoll = cos(RotRad.z) + KINDA_SMALL_NUMBER;

        // Optionally invert rotation
        if (bInverse)
        {
            SinPitch = -SinPitch;
            SinYaw = -SinYaw;
            SinRoll = -SinRoll;
        }

        // Apply rotation in Yaw → Pitch → Roll order (YXZ)
        float3 Rotated;
    
        // Yaw (around Y)
        float3 AfterYaw;
        AfterYaw.x = Vector.x * CosYaw + Vector.z * SinYaw;
        AfterYaw.y = Vector.y;
        AfterYaw.z = -Vector.x * SinYaw + Vector.z * CosYaw;

        // Pitch (around X)
        float3 AfterPitch;
        AfterPitch.x = AfterYaw.x;
        AfterPitch.y = AfterYaw.y * CosPitch - AfterYaw.z * SinPitch;
        AfterPitch.z = AfterYaw.y * SinPitch + AfterYaw.z * CosPitch;

        // Roll (around Z)
        Rotated.x = AfterPitch.x * CosRoll - AfterPitch.y * SinRoll;
        Rotated.y = AfterPitch.x * SinRoll + AfterPitch.y * CosRoll;
        Rotated.z = AfterPitch.z;

        return Rotated;
    }

};